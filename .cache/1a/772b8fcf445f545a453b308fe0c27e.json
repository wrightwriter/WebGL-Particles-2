{"id":"src/shaders.js","dependencies":[{"name":"Z:\\ProgrammingProjects\\VisualAudio\\particle-system-webgl\\WebGL-Particle-nator\\package.json","includedInParent":true,"mtime":1578144868423}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeShaderSourceOld = exports.computeShaderSource = exports.fragmentShaderSource = exports.vertexShaderSource = void 0;\nvar vertexShaderSource = \"#version 300 es\\n\\nin vec4 a_position;\\n// in vec4 a_color;\\n\\n// layout (rgba8, binding = 0) uniform readonly highp image2D u_distTex;\\n\\nuniform mat4 u_matrix;\\nuniform float u_fudgeFactor;\\n// uniform sampler2D u_distTex;\\nuniform int u_particleId;\\nuniform int u_particleCount;\\nuniform vec2 u_resolution;\\nuniform vec2 u_positionMouse;\\n\\nout vec4 v_color;\\n\\nvoid main() {\\n  //vec4 position = u_matrix * a_position;\\n\\n  float id = float(u_particleId);\\n  float particleCount = float(u_particleCount);\\n  float fracId = id/particleCount;\\n\\n  // float t =   texture(u_distTex,vec2(fracId,0)).x;\\n  // float t =   imageLoad(u_distTex,ivec2(u_particleId,0)).x;\\n  vec4 position = u_matrix * vec4(0. + fracId*u_resolution.x + u_positionMouse.x*u_resolution.y,0. + fracId*u_resolution.y ,1.,1.);\\n  // vec4 position = u_matrix * vec4(0. + t*100000. + u_positionMouse.x*u_resolution.y,0. + fracId*u_resolution.y ,1.,1.);\\n  \\n  float zToDivideBy = 1.;\\n  gl_PointSize = 2.0;\\n  // v_color = a_color;\\n  v_color = vec4(1);\\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\\n}\\n\";\nexports.vertexShaderSource = vertexShaderSource;\nvar fragmentShaderSource = \"#version 300 es\\n\\nprecision mediump float;\\n\\nin vec4 v_color;\\n\\nout vec4 outColor;\\n\\nvoid main() {\\n  // outColor = v_color;\\n  outColor = vec4(0,0,1,1.);\\n}\\n\";\nexports.fragmentShaderSource = fragmentShaderSource;\nvar computeShaderSource = \"#version 310 es\\n  layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\\n  layout (rgba8, binding = 0) uniform writeonly highp image2D destTex;\\n  // layout (rgba8, binding = 1) uniform readonly highp image2D sampleTex;\\n\\n  uniform vec2 u_resolution;\\n  uniform vec2 u_positionMouse;\\n  uniform int u_particleCount;\\n  uniform float u_timeElapsed;\\n  void main() {\\n    ivec2 posGlobal = ivec2(gl_GlobalInvocationID.xy);\\n    // vec4 col =  vec4(vec2(gl_WorkGroupID.xy) / vec2(gl_NumWorkGroups.xy), 0.0, 1.0);\\n\\n    vec2 positionMouse = u_positionMouse - 0.5;\\n    // vec2 directionMouse = normalize(positionMouse - previous.xy );\\n    vec4 col = vec4(0);\\n    // vec4 col = vec4(1,0,0,1);\\n\\n    if (u_timeElapsed <=  222200.) {\\n      col = vec4(1,0,0,1);\\n    } else {\\n      // vec4 previous = imageLoad(sampleTex, posGlobal);\\n      // col = previous;\\n    }\\n\\n    // col += float(u_particleCount)*0.0009;\\n    // col =  vec4(0.000001*float(gl_LocalInvocationID.x) / float(u_particleCount));\\n    // col -= 1000.;\\n    // col =  vec4(gl_WorkGroupID.x/2.);\\n    imageStore(destTex, posGlobal, col );\\n  }\\n\\n\";\nexports.computeShaderSource = computeShaderSource;\nvar computeShaderSourceOld = \"#version 310 es\\n  layout (local_size_x = \".concat(1, \", local_size_y = 1, local_size_z = 1) in;\\n\\n  // layout (std140, binding = 0) buffer SSBOIn {\\n  //   Boids data[];\\n  //  } ssboIn;\\n\\n  struct Particle {\\n    vec3 position;\\n    vec3 velocity;\\n  }\\n  // shared Particle sharedData[\", 10, \"];\\n\\n  void main () {\\n    uint localThreadID = gl_LocallInvocationID.x;\\n    uint globalThreadID = gl_GlobalInvocationID.x;\\n    uint workGroupSize = gl_WorkGroupSize.x;\\n  }\\n\\n\\n\"); // export let fragmentShaderSource = `#version 310 es\n// precision mediump float;\n// // Passed in and varied from the vertex shader.\n// in vec3 v_normal;\n// uniform vec3 u_reverseLightDirection;\n// uniform vec4 u_color;\n// // we need to declare an output for the fragment shader\n// out vec4 outColor;\n// void main() {\n//   // because v_normal is a varying it's interpolated\n//   // so it will not be a uint vector. Normalizing it\n//   // will make it a unit vector again\n//   vec3 normal = normalize(v_normal);\n//   // compute the light by taking the dot product\n//   // of the normal to the light's reverse direction\n//   float light = dot(normal, u_reverseLightDirection);\n//   outColor = u_color;\n//   // Lets multiply just the color portion (not the alpha)\n//   // by the light\n//   outColor.rgb *= light;\n// }\n// `;\n\nexports.computeShaderSourceOld = computeShaderSourceOld;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"src/shaders.js","original":{"line":1,"column":7}},{"name":"vertexShaderSource","generated":{"line":7,"column":4},"source":"src/shaders.js","original":{"line":1,"column":11}},{"generated":{"line":7,"column":22},"source":"src/shaders.js","original":{"line":1,"column":29}},{"generated":{"line":7,"column":1118},"source":"src/shaders.js","original":{"line":1,"column":7}},{"generated":{"line":9,"column":0},"source":"src/shaders.js","original":{"line":38,"column":7}},{"name":"fragmentShaderSource","generated":{"line":9,"column":4},"source":"src/shaders.js","original":{"line":38,"column":13}},{"generated":{"line":9,"column":24},"source":"src/shaders.js","original":{"line":38,"column":33}},{"generated":{"line":9,"column":192},"source":"src/shaders.js","original":{"line":38,"column":7}},{"generated":{"line":11,"column":0},"source":"src/shaders.js","original":{"line":51,"column":7}},{"name":"computeShaderSource","generated":{"line":11,"column":4},"source":"src/shaders.js","original":{"line":51,"column":13}},{"generated":{"line":11,"column":23},"source":"src/shaders.js","original":{"line":51,"column":32}},{"generated":{"line":11,"column":1156},"source":"src/shaders.js","original":{"line":51,"column":7}},{"generated":{"line":13,"column":0},"source":"src/shaders.js","original":{"line":84,"column":7}},{"name":"computeShaderSourceOld","generated":{"line":13,"column":4},"source":"src/shaders.js","original":{"line":84,"column":13}},{"generated":{"line":13,"column":26},"source":"src/shaders.js","original":{"line":84,"column":35}},{"generated":{"line":13,"column":81},"source":"src/shaders.js","original":{"line":85,"column":27}},{"generated":{"line":13,"column":82},"source":"src/shaders.js","original":{"line":84,"column":35}},{"generated":{"line":13,"column":323},"source":"src/shaders.js","original":{"line":95,"column":34}},{"generated":{"line":13,"column":325},"source":"src/shaders.js","original":{"line":84,"column":35}},{"generated":{"line":13,"column":512},"source":"src/shaders.js","original":{"line":84,"column":7}},{"generated":{"line":13,"column":514},"source":"src/shaders.js","original":{"line":106,"column":0}},{"generated":{"line":14,"column":0},"source":"src/shaders.js","original":{"line":108,"column":0}},{"generated":{"line":15,"column":0},"source":"src/shaders.js","original":{"line":110,"column":0}},{"generated":{"line":16,"column":0},"source":"src/shaders.js","original":{"line":111,"column":0}},{"generated":{"line":17,"column":0},"source":"src/shaders.js","original":{"line":113,"column":0}},{"generated":{"line":18,"column":0},"source":"src/shaders.js","original":{"line":114,"column":0}},{"generated":{"line":19,"column":0},"source":"src/shaders.js","original":{"line":116,"column":0}},{"generated":{"line":20,"column":0},"source":"src/shaders.js","original":{"line":117,"column":0}},{"generated":{"line":21,"column":0},"source":"src/shaders.js","original":{"line":119,"column":0}},{"generated":{"line":22,"column":0},"source":"src/shaders.js","original":{"line":120,"column":0}},{"generated":{"line":23,"column":0},"source":"src/shaders.js","original":{"line":121,"column":0}},{"generated":{"line":24,"column":0},"source":"src/shaders.js","original":{"line":122,"column":0}},{"generated":{"line":25,"column":0},"source":"src/shaders.js","original":{"line":123,"column":0}},{"generated":{"line":26,"column":0},"source":"src/shaders.js","original":{"line":125,"column":0}},{"generated":{"line":27,"column":0},"source":"src/shaders.js","original":{"line":126,"column":0}},{"generated":{"line":28,"column":0},"source":"src/shaders.js","original":{"line":127,"column":0}},{"generated":{"line":29,"column":0},"source":"src/shaders.js","original":{"line":129,"column":0}},{"generated":{"line":30,"column":0},"source":"src/shaders.js","original":{"line":131,"column":0}},{"generated":{"line":31,"column":0},"source":"src/shaders.js","original":{"line":132,"column":0}},{"generated":{"line":32,"column":0},"source":"src/shaders.js","original":{"line":133,"column":0}},{"generated":{"line":33,"column":0},"source":"src/shaders.js","original":{"line":134,"column":0}},{"generated":{"line":34,"column":0},"source":"src/shaders.js","original":{"line":135,"column":0}}],"sources":{"src/shaders.js":"export let vertexShaderSource = `#version 300 es\r\n\r\nin vec4 a_position;\r\n// in vec4 a_color;\r\n\r\n// layout (rgba8, binding = 0) uniform readonly highp image2D u_distTex;\r\n\r\nuniform mat4 u_matrix;\r\nuniform float u_fudgeFactor;\r\n// uniform sampler2D u_distTex;\r\nuniform int u_particleId;\r\nuniform int u_particleCount;\r\nuniform vec2 u_resolution;\r\nuniform vec2 u_positionMouse;\r\n\r\nout vec4 v_color;\r\n\r\nvoid main() {\r\n  //vec4 position = u_matrix * a_position;\r\n\r\n  float id = float(u_particleId);\r\n  float particleCount = float(u_particleCount);\r\n  float fracId = id/particleCount;\r\n\r\n  // float t =   texture(u_distTex,vec2(fracId,0)).x;\r\n  // float t =   imageLoad(u_distTex,ivec2(u_particleId,0)).x;\r\n  vec4 position = u_matrix * vec4(0. + fracId*u_resolution.x + u_positionMouse.x*u_resolution.y,0. + fracId*u_resolution.y ,1.,1.);\r\n  // vec4 position = u_matrix * vec4(0. + t*100000. + u_positionMouse.x*u_resolution.y,0. + fracId*u_resolution.y ,1.,1.);\r\n  \r\n  float zToDivideBy = 1.;\r\n  gl_PointSize = 2.0;\r\n  // v_color = a_color;\r\n  v_color = vec4(1);\r\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\r\n}\r\n`;\r\n\r\nexport const fragmentShaderSource = `#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nin vec4 v_color;\r\n\r\nout vec4 outColor;\r\n\r\nvoid main() {\r\n  // outColor = v_color;\r\n  outColor = vec4(0,0,1,1.);\r\n}\r\n`;\r\nexport const computeShaderSource = `#version 310 es\r\n  layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\r\n  layout (rgba8, binding = 0) uniform writeonly highp image2D destTex;\r\n  // layout (rgba8, binding = 1) uniform readonly highp image2D sampleTex;\r\n\r\n  uniform vec2 u_resolution;\r\n  uniform vec2 u_positionMouse;\r\n  uniform int u_particleCount;\r\n  uniform float u_timeElapsed;\r\n  void main() {\r\n    ivec2 posGlobal = ivec2(gl_GlobalInvocationID.xy);\r\n    // vec4 col =  vec4(vec2(gl_WorkGroupID.xy) / vec2(gl_NumWorkGroups.xy), 0.0, 1.0);\r\n\r\n    vec2 positionMouse = u_positionMouse - 0.5;\r\n    // vec2 directionMouse = normalize(positionMouse - previous.xy );\r\n    vec4 col = vec4(0);\r\n    // vec4 col = vec4(1,0,0,1);\r\n\r\n    if (u_timeElapsed <=  222200.) {\r\n      col = vec4(1,0,0,1);\r\n    } else {\r\n      // vec4 previous = imageLoad(sampleTex, posGlobal);\r\n      // col = previous;\r\n    }\r\n\r\n    // col += float(u_particleCount)*0.0009;\r\n    // col =  vec4(0.000001*float(gl_LocalInvocationID.x) / float(u_particleCount));\r\n    // col -= 1000.;\r\n    // col =  vec4(gl_WorkGroupID.x/2.);\r\n    imageStore(destTex, posGlobal, col );\r\n  }\r\n\r\n`;\r\nexport const computeShaderSourceOld = `#version 310 es\r\n  layout (local_size_x = ${1}, local_size_y = 1, local_size_z = 1) in;\r\n\r\n  // layout (std140, binding = 0) buffer SSBOIn {\r\n  //   Boids data[];\r\n  //  } ssboIn;\r\n\r\n  struct Particle {\r\n    vec3 position;\r\n    vec3 velocity;\r\n  }\r\n  // shared Particle sharedData[${10}];\r\n\r\n  void main () {\r\n    uint localThreadID = gl_LocallInvocationID.x;\r\n    uint globalThreadID = gl_GlobalInvocationID.x;\r\n    uint workGroupSize = gl_WorkGroupSize.x;\r\n  }\r\n\r\n\r\n`;\r\n\r\n// export let fragmentShaderSource = `#version 310 es\r\n\r\n// precision mediump float;\r\n\r\n// // Passed in and varied from the vertex shader.\r\n// in vec3 v_normal;\r\n\r\n// uniform vec3 u_reverseLightDirection;\r\n// uniform vec4 u_color;\r\n\r\n// // we need to declare an output for the fragment shader\r\n// out vec4 outColor;\r\n\r\n// void main() {\r\n//   // because v_normal is a varying it's interpolated\r\n//   // so it will not be a uint vector. Normalizing it\r\n//   // will make it a unit vector again\r\n//   vec3 normal = normalize(v_normal);\r\n\r\n//   // compute the light by taking the dot product\r\n//   // of the normal to the light's reverse direction\r\n//   float light = dot(normal, u_reverseLightDirection);\r\n\r\n//   outColor = u_color;\r\n\r\n//   // Lets multiply just the color portion (not the alpha)\r\n//   // by the light\r\n//   outColor.rgb *= light;\r\n// }\r\n// `;\r\n"},"lineCount":null}},"error":null,"hash":"8228722e2a8f20d4d58725ca230b38a1","cacheData":{"env":{}}}