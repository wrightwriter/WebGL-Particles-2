{"id":"src/shaders.js","dependencies":[{"name":"Z:\\ProgrammingProjects\\VisualAudio\\particle-system-webgl\\WebGL-Particle-nator\\package.json","includedInParent":true,"mtime":1578144868423},{"name":"./vars","loc":{"line":1,"column":28},"parent":"Z:\\ProgrammingProjects\\VisualAudio\\particle-system-webgl\\WebGL-Particle-nator\\src\\shaders.js","resolved":"Z:\\ProgrammingProjects\\VisualAudio\\particle-system-webgl\\WebGL-Particle-nator\\src\\vars.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeShaderSource = exports.fragmentShaderSource = exports.vertexShaderSource = exports.fragmentShaderRectangleSource = exports.vertexShaderRectangleSource = void 0;\n\nvar _vars = require(\"./vars\");\n\nvar vertexShaderRectangleSource = \"#version 310 es\\nin vec4 a_position;\\n\\nuniform mat4 u_matrix;\\nuniform float u_fudgeFactor;\\nuniform vec2 u_resolution;\\n\\nout vec4 v_color;\\nout vec4 v_position;\\n\\nvoid main() {\\n\\n  vec4 position = u_matrix * a_position;\\n  float zToDivideBy = 1.;\\n  v_color = vec4(1,1,1,1.);\\n  v_position = a_position;\\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\\n}\\n\\n\";\nexports.vertexShaderRectangleSource = vertexShaderRectangleSource;\nvar fragmentShaderRectangleSource = \"#version 310 es\\nprecision highp float;\\nin vec4 v_color;\\nin vec4 v_position;\\nout vec4 outColor;\\n\\nuniform vec2 u_resolution;\\nuniform sampler2D u_previousFrame;\\nuniform sampler2D u_currFrame;\\n\\nvoid main() {\\n  vec2 uv = v_position.xy/u_resolution;\\n\\n  uv *= 1.0;\\n  uv.y = 1. - uv.y;\\n\\n  outColor = vec4(0,0,0,1);\\n  vec3 previous =  texture(u_previousFrame,uv).xyz;\\n  vec3 curr =  texture(u_currFrame,uv).xyz;\\n\\n  outColor.xyz += previous*1. + curr*1.0;\\n}\\n\";\nexports.fragmentShaderRectangleSource = fragmentShaderRectangleSource;\nvar vertexShaderSource = \"#version 310 es\\n\\n\\nin vec4 a_position;\\n// in vec4 a_color;\\n\\n// layout (rgba8, binding = 0) uniform readonly highp image2D u_distTex;\\n\\nuniform mat4 u_matrix;\\nuniform float u_fudgeFactor;\\n// uniform sampler2D u_distTex;\\nuniform int u_particleId;\\nuniform int u_particleCount;\\nuniform vec2 u_resolution;\\nuniform vec2 u_positionMouse;\\n\\n// layout (std430, binding = 0) buffer SSBO {\\n//   vec3 data[];\\n// } ssbo;\\nstruct Particle {\\n  vec3 position;\\n  vec3 velocity;\\n};\\nlayout (location = 0) in vec3 particle;\\nlayout (location = 1) in vec3 particleVelocity;\\n\\nout vec4 v_color;\\n\\nvoid main() {\\n  float particleCount = float(u_particleCount);\\n\\n  Particle t = Particle(particle,particleVelocity);\\n\\n  vec4 position = u_matrix * vec4(0. + t.position.x*u_resolution.x,u_resolution.y-t.position.y*u_resolution.y,1.,1.);\\n  // vec4 position = u_matrix * vec4(0. + u_positionMouse.x*u_resolution.x,u_resolution.y-t.position.y*u_resolution.y,1.,1.);\\n  \\n  float zToDivideBy = 1.;\\n  gl_PointSize = 4.0;\\n  v_color = vec4(particleVelocity,1.);\\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\\n}\\n\";\nexports.vertexShaderSource = vertexShaderSource;\nvar fragmentShaderSource = \"#version 310 es\\n\\nprecision mediump float;\\n\\nin vec4 v_color;\\n\\nout vec4 outColor;\\n\\n\\nvoid main() {\\n  // outColor = v_color;\\n  vec2 uv = 2.*gl_PointCoord - 1.;\\n\\n  float r = 1.;\\n  outColor = vec4(v_color.x,v_color.y,1,1.) * smoothstep(r, r*0.99, length(uv));\\n}\\n\";\nexports.fragmentShaderSource = fragmentShaderSource;\nvar computeShaderSource = \"#version 310 es\\n  layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\\n\\n  struct Particle {\\n    vec3 position;\\n    vec3 velocity;\\n  };\\n\\n  layout (std430, binding = 0) buffer SSBO {\\n    vec3 position[\".concat(_vars.NUM_PARTICLES, \"]; // TODO: make this an import\\n    vec3 velocity[\").concat(_vars.NUM_PARTICLES, \"];\\n  } ssbo;\\n\\n  uniform vec2 u_resolution;\\n  uniform vec2 u_positionMouse;\\n  uniform float u_mousePressed;\\n  uniform int u_particleCount;\\n  uniform float u_timeElapsed;\\n  uniform float u_avoidance;\\n  uniform vec2 u_gravity;\\n  \\n\\n  float r11(float i) {return fract(sin(i*212.12)*124.41);}\\n  vec3 r13(float i) {return vec3( r11(i), r11(i*2.4), r11(i*1.57));} \\n\\n  void main() {\\n    ivec2 posGlobal = ivec2(gl_GlobalInvocationID.xy);\\n\\n    // Particle previous = ssbo.particle[posGlobal.x];\\n    // Particle previous = Particle(ssbo.position[posGlobal.x], ssbo.velocity[posGlobal.x]);\\n    Particle previous = Particle(ssbo.position[posGlobal.x], ssbo.velocity[posGlobal.x]);\\n    Particle next = previous;\\n\\n    vec2 positionMouse = u_positionMouse ;\\n    vec2 directionMouse = normalize(positionMouse - previous.position.xy );\\n\\n\\n    if (u_timeElapsed <=  20.) {\\n      // ssbo.position[posGlobal.x] = vec3(0.5,0.5,1);\\n      ssbo.position[posGlobal.x] = r13(float(posGlobal.x) + 1.);\\n      ssbo.position[posGlobal.x].z = 1.;\\n      // ssbo.velocity[posGlobal.x] = vec3(0);\\n    } else {\\n      // -- bounds -- //\\n      if (previous.position.x < 0.) {\\n        previous.velocity.x = -1.*abs(previous.velocity.x);\\n      }\\n      if (previous.position.x > 1.){\\n        previous.velocity.x = 1.*abs(previous.velocity.x);\\n      }\\n      if (previous.position.y < 0.) {\\n        previous.velocity.y = -1.*abs(previous.velocity.y);\\n      }\\n      if (previous.position.y > 1.) {\\n        previous.velocity.y = 1.*abs(previous.velocity.y);\\n      }\\n      \\n      // -- mouse -- //\\n      if (u_mousePressed == 1.) {\\n        previous.velocity.x -= directionMouse.x*0.0001;\\n        previous.velocity.y -= directionMouse.y*0.0003;\\n      }\\n\\n\\n      \\n      // -- avoidance -- //\\n      for (int i = 0; i < u_particleCount; i++) {\\n        vec3 otherPos = ssbo.position[int(i)];\\n        vec3 direction = normalize(otherPos - previous.position);\\n        float dis = length(otherPos - previous.position);\\n        previous.velocity += direction * exp(-dis*(200. - u_avoidance*190.))*0.0001;\\n      }\\n\\n      // -- vortex -- //\\n      float frId = 10.*float(posGlobal.x)/float(u_particleCount);\\n      vec2 vortexPos = vec2(sin(frId + u_timeElapsed*0.001), cos(frId + u_timeElapsed*0.001))*0.5 + 0.5;\\n      vec2 vortexDir = normalize(vortexPos - previous.position.xy);\\n      // previous.velocity.xy -= vortexDir*0.0001;\\n      \\n\\n\\n      \\n      // -- damping -- //\\n      previous.velocity *= 0.99;\\n      // -- gravity -- //\\n      previous.velocity.xy -= u_gravity*0.0003;\\n\\n      next.position -= previous.velocity;\\n      next.velocity = previous.velocity;\\n\\n      // -- bounds -- //\\n      // if (next.position.y == 0.) {\\n      //   next.position.y = abs(next.position.y);        \\n      // }\\n      // next.position.y = max(next.position.y, 0.);\\n      // next.position.xy = max(min(next.position.xy, vec2(1.)), vec2(0));\\n\\n      ssbo.position[posGlobal.x] = next.position;\\n      ssbo.velocity[posGlobal.x] = next.velocity;\\n    }\\n\\n  }\\n\\n\\n\");\nexports.computeShaderSource = computeShaderSource;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":8,"column":0},"source":"src/shaders.js","original":{"line":1,"column":0}},{"generated":{"line":10,"column":0},"source":"src/shaders.js","original":{"line":3,"column":7}},{"name":"vertexShaderRectangleSource","generated":{"line":10,"column":4},"source":"src/shaders.js","original":{"line":3,"column":13}},{"generated":{"line":10,"column":31},"source":"src/shaders.js","original":{"line":3,"column":40}},{"generated":{"line":10,"column":414},"source":"src/shaders.js","original":{"line":3,"column":7}},{"generated":{"line":12,"column":0},"source":"src/shaders.js","original":{"line":23,"column":7}},{"name":"fragmentShaderRectangleSource","generated":{"line":12,"column":4},"source":"src/shaders.js","original":{"line":23,"column":13}},{"generated":{"line":12,"column":33},"source":"src/shaders.js","original":{"line":23,"column":42}},{"generated":{"line":12,"column":508},"source":"src/shaders.js","original":{"line":23,"column":7}},{"generated":{"line":14,"column":0},"source":"src/shaders.js","original":{"line":46,"column":7}},{"name":"vertexShaderSource","generated":{"line":14,"column":4},"source":"src/shaders.js","original":{"line":46,"column":13}},{"generated":{"line":14,"column":22},"source":"src/shaders.js","original":{"line":46,"column":31}},{"generated":{"line":14,"column":1150},"source":"src/shaders.js","original":{"line":46,"column":7}},{"generated":{"line":16,"column":0},"source":"src/shaders.js","original":{"line":89,"column":7}},{"name":"fragmentShaderSource","generated":{"line":16,"column":4},"source":"src/shaders.js","original":{"line":89,"column":13}},{"generated":{"line":16,"column":24},"source":"src/shaders.js","original":{"line":89,"column":33}},{"generated":{"line":16,"column":301},"source":"src/shaders.js","original":{"line":89,"column":7}},{"generated":{"line":18,"column":0},"source":"src/shaders.js","original":{"line":106,"column":7}},{"name":"computeShaderSource","generated":{"line":18,"column":4},"source":"src/shaders.js","original":{"line":106,"column":13}},{"generated":{"line":18,"column":23},"source":"src/shaders.js","original":{"line":106,"column":32}},{"name":"NUM_PARTICLES","generated":{"line":18,"column":257},"source":"src/shaders.js","original":{"line":115,"column":20}},{"generated":{"line":18,"column":276},"source":"src/shaders.js","original":{"line":106,"column":32}},{"name":"NUM_PARTICLES","generated":{"line":18,"column":340},"source":"src/shaders.js","original":{"line":116,"column":20}},{"generated":{"line":18,"column":359},"source":"src/shaders.js","original":{"line":106,"column":32}},{"generated":{"line":18,"column":3439},"source":"src/shaders.js","original":{"line":106,"column":7}}],"sources":{"src/shaders.js":"import {NUM_PARTICLES} from './vars'\r\n\r\nexport const vertexShaderRectangleSource = `#version 310 es\r\nin vec4 a_position;\r\n\r\nuniform mat4 u_matrix;\r\nuniform float u_fudgeFactor;\r\nuniform vec2 u_resolution;\r\n\r\nout vec4 v_color;\r\nout vec4 v_position;\r\n\r\nvoid main() {\r\n\r\n  vec4 position = u_matrix * a_position;\r\n  float zToDivideBy = 1.;\r\n  v_color = vec4(1,1,1,1.);\r\n  v_position = a_position;\r\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\r\n}\r\n\r\n`\r\nexport const fragmentShaderRectangleSource = `#version 310 es\r\nprecision highp float;\r\nin vec4 v_color;\r\nin vec4 v_position;\r\nout vec4 outColor;\r\n\r\nuniform vec2 u_resolution;\r\nuniform sampler2D u_previousFrame;\r\nuniform sampler2D u_currFrame;\r\n\r\nvoid main() {\r\n  vec2 uv = v_position.xy/u_resolution;\r\n\r\n  uv *= 1.0;\r\n  uv.y = 1. - uv.y;\r\n\r\n  outColor = vec4(0,0,0,1);\r\n  vec3 previous =  texture(u_previousFrame,uv).xyz;\r\n  vec3 curr =  texture(u_currFrame,uv).xyz;\r\n\r\n  outColor.xyz += previous*1. + curr*1.0;\r\n}\r\n`;\r\nexport const vertexShaderSource = `#version 310 es\r\n\r\n\r\nin vec4 a_position;\r\n// in vec4 a_color;\r\n\r\n// layout (rgba8, binding = 0) uniform readonly highp image2D u_distTex;\r\n\r\nuniform mat4 u_matrix;\r\nuniform float u_fudgeFactor;\r\n// uniform sampler2D u_distTex;\r\nuniform int u_particleId;\r\nuniform int u_particleCount;\r\nuniform vec2 u_resolution;\r\nuniform vec2 u_positionMouse;\r\n\r\n// layout (std430, binding = 0) buffer SSBO {\r\n//   vec3 data[];\r\n// } ssbo;\r\nstruct Particle {\r\n  vec3 position;\r\n  vec3 velocity;\r\n};\r\nlayout (location = 0) in vec3 particle;\r\nlayout (location = 1) in vec3 particleVelocity;\r\n\r\nout vec4 v_color;\r\n\r\nvoid main() {\r\n  float particleCount = float(u_particleCount);\r\n\r\n  Particle t = Particle(particle,particleVelocity);\r\n\r\n  vec4 position = u_matrix * vec4(0. + t.position.x*u_resolution.x,u_resolution.y-t.position.y*u_resolution.y,1.,1.);\r\n  // vec4 position = u_matrix * vec4(0. + u_positionMouse.x*u_resolution.x,u_resolution.y-t.position.y*u_resolution.y,1.,1.);\r\n  \r\n  float zToDivideBy = 1.;\r\n  gl_PointSize = 4.0;\r\n  v_color = vec4(particleVelocity,1.);\r\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\r\n}\r\n`;\r\n\r\nexport const fragmentShaderSource = `#version 310 es\r\n\r\nprecision mediump float;\r\n\r\nin vec4 v_color;\r\n\r\nout vec4 outColor;\r\n\r\n\r\nvoid main() {\r\n  // outColor = v_color;\r\n  vec2 uv = 2.*gl_PointCoord - 1.;\r\n\r\n  float r = 1.;\r\n  outColor = vec4(v_color.x,v_color.y,1,1.) * smoothstep(r, r*0.99, length(uv));\r\n}\r\n`;\r\nexport const computeShaderSource = `#version 310 es\r\n  layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\r\n\r\n  struct Particle {\r\n    vec3 position;\r\n    vec3 velocity;\r\n  };\r\n\r\n  layout (std430, binding = 0) buffer SSBO {\r\n    vec3 position[${NUM_PARTICLES}]; // TODO: make this an import\r\n    vec3 velocity[${NUM_PARTICLES}];\r\n  } ssbo;\r\n\r\n  uniform vec2 u_resolution;\r\n  uniform vec2 u_positionMouse;\r\n  uniform float u_mousePressed;\r\n  uniform int u_particleCount;\r\n  uniform float u_timeElapsed;\r\n  uniform float u_avoidance;\r\n  uniform vec2 u_gravity;\r\n  \r\n\r\n  float r11(float i) {return fract(sin(i*212.12)*124.41);}\r\n  vec3 r13(float i) {return vec3( r11(i), r11(i*2.4), r11(i*1.57));} \r\n\r\n  void main() {\r\n    ivec2 posGlobal = ivec2(gl_GlobalInvocationID.xy);\r\n\r\n    // Particle previous = ssbo.particle[posGlobal.x];\r\n    // Particle previous = Particle(ssbo.position[posGlobal.x], ssbo.velocity[posGlobal.x]);\r\n    Particle previous = Particle(ssbo.position[posGlobal.x], ssbo.velocity[posGlobal.x]);\r\n    Particle next = previous;\r\n\r\n    vec2 positionMouse = u_positionMouse ;\r\n    vec2 directionMouse = normalize(positionMouse - previous.position.xy );\r\n\r\n\r\n    if (u_timeElapsed <=  20.) {\r\n      // ssbo.position[posGlobal.x] = vec3(0.5,0.5,1);\r\n      ssbo.position[posGlobal.x] = r13(float(posGlobal.x) + 1.);\r\n      ssbo.position[posGlobal.x].z = 1.;\r\n      // ssbo.velocity[posGlobal.x] = vec3(0);\r\n    } else {\r\n      // -- bounds -- //\r\n      if (previous.position.x < 0.) {\r\n        previous.velocity.x = -1.*abs(previous.velocity.x);\r\n      }\r\n      if (previous.position.x > 1.){\r\n        previous.velocity.x = 1.*abs(previous.velocity.x);\r\n      }\r\n      if (previous.position.y < 0.) {\r\n        previous.velocity.y = -1.*abs(previous.velocity.y);\r\n      }\r\n      if (previous.position.y > 1.) {\r\n        previous.velocity.y = 1.*abs(previous.velocity.y);\r\n      }\r\n      \r\n      // -- mouse -- //\r\n      if (u_mousePressed == 1.) {\r\n        previous.velocity.x -= directionMouse.x*0.0001;\r\n        previous.velocity.y -= directionMouse.y*0.0003;\r\n      }\r\n\r\n\r\n      \r\n      // -- avoidance -- //\r\n      for (int i = 0; i < u_particleCount; i++) {\r\n        vec3 otherPos = ssbo.position[int(i)];\r\n        vec3 direction = normalize(otherPos - previous.position);\r\n        float dis = length(otherPos - previous.position);\r\n        previous.velocity += direction * exp(-dis*(200. - u_avoidance*190.))*0.0001;\r\n      }\r\n\r\n      // -- vortex -- //\r\n      float frId = 10.*float(posGlobal.x)/float(u_particleCount);\r\n      vec2 vortexPos = vec2(sin(frId + u_timeElapsed*0.001), cos(frId + u_timeElapsed*0.001))*0.5 + 0.5;\r\n      vec2 vortexDir = normalize(vortexPos - previous.position.xy);\r\n      // previous.velocity.xy -= vortexDir*0.0001;\r\n      \r\n\r\n\r\n      \r\n      // -- damping -- //\r\n      previous.velocity *= 0.99;\r\n      // -- gravity -- //\r\n      previous.velocity.xy -= u_gravity*0.0003;\r\n\r\n      next.position -= previous.velocity;\r\n      next.velocity = previous.velocity;\r\n\r\n      // -- bounds -- //\r\n      // if (next.position.y == 0.) {\r\n      //   next.position.y = abs(next.position.y);        \r\n      // }\r\n      // next.position.y = max(next.position.y, 0.);\r\n      // next.position.xy = max(min(next.position.xy, vec2(1.)), vec2(0));\r\n\r\n      ssbo.position[posGlobal.x] = next.position;\r\n      ssbo.velocity[posGlobal.x] = next.velocity;\r\n    }\r\n\r\n  }\r\n\r\n\r\n`;\r\n\r\n"},"lineCount":null}},"error":null,"hash":"2a8efa845cebf2cb9487080d67432640","cacheData":{"env":{}}}