{"id":"src/shaders.js","dependencies":[{"name":"Z:\\ProgrammingProjects\\VisualAudio\\particle-system-webgl\\WebGL-Particle-nator\\package.json","includedInParent":true,"mtime":1578144868423},{"name":"./index","loc":{"line":1,"column":28},"parent":"Z:\\ProgrammingProjects\\VisualAudio\\particle-system-webgl\\WebGL-Particle-nator\\src\\shaders.js","resolved":"Z:\\ProgrammingProjects\\VisualAudio\\particle-system-webgl\\WebGL-Particle-nator\\src\\index.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeShaderSourceOld = exports.computeShaderSource = exports.fragmentShaderSource = exports.vertexShaderSource = void 0;\n\nvar _index = require(\"./index\");\n\nvar vertexShaderSource = \"#version 310 es\\n\\n\\nin vec4 a_position;\\n// in vec4 a_color;\\n\\n// layout (rgba8, binding = 0) uniform readonly highp image2D u_distTex;\\n\\nuniform mat4 u_matrix;\\nuniform float u_fudgeFactor;\\n// uniform sampler2D u_distTex;\\nuniform int u_particleId;\\nuniform int u_particleCount;\\nuniform vec2 u_resolution;\\nuniform vec2 u_positionMouse;\\n\\n// layout (std430, binding = 0) buffer SSBO {\\n//   vec3 data[];\\n// } ssbo;\\nstruct Particle {\\n  vec3 position;\\n  vec3 velocity;\\n};\\nlayout (location = 0) in vec3 particle;\\nlayout (location = 1) in vec3 particleVelocity;\\n\\nout vec4 v_color;\\n\\nvoid main() {\\n  //vec4 position = u_matrix * a_position;\\n\\n  // float id = float(u_particleId);\\n  float particleCount = float(u_particleCount);\\n  // float fracId = id/particleCount;\\n\\n  Particle t = Particle(particle,particleVelocity);\\n  // t *= 0.1;\\n  // float t =   imageLoad(u_distTex,ivec2(u_particleId,0)).x;\\n  // vec4 position = u_matrix * vec4(0. + sin(t.x)*1000. + fracId*u_resolution.x + u_positionMouse.x*u_resolution.y,0. + fracId*u_resolution.y ,1.,1.);\\n  // vec4 position = u_matrix * vec4(0. + 1.*t.x*u_resolution.y + u_positionMouse.x*u_resolution.y,0. + t.y*u_resolution.y ,1.,1.);\\n  vec4 position = u_matrix * vec4(0. + t.position.x*u_resolution.x,u_resolution.y-t.position.y*u_resolution.y,0.,1.);\\n  \\n  float zToDivideBy = 1.;\\n  gl_PointSize = 10.0;\\n  // v_color = a_color;\\n  v_color = vec4(1);\\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\\n}\\n\";\nexports.vertexShaderSource = vertexShaderSource;\nvar fragmentShaderSource = \"#version 310 es\\n\\nprecision mediump float;\\n\\nin vec4 v_color;\\n\\nout vec4 outColor;\\n\\n\\nvoid main() {\\n  // outColor = v_color;\\n  outColor = vec4(0,0,1,1.);\\n}\\n\";\nexports.fragmentShaderSource = fragmentShaderSource;\nvar computeShaderSource = \"#version 310 es\\n  layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\\n\\n  struct Particle {\\n    vec3 position;\\n    vec3 velocity;\\n  };\\n\\n  layout (std430, binding = 0) buffer SSBO {\\n    vec3 position[\".concat(1000, \"]; // TODO: make this an import\\n    vec3 velocity[\", 1000, \"];\\n  } ssbo;\\n\\n  uniform vec2 u_resolution;\\n  uniform vec2 u_positionMouse;\\n  uniform int u_particleCount;\\n  uniform float u_timeElapsed;\\n  void main() {\\n    ivec2 posGlobal = ivec2(gl_GlobalInvocationID.xy);\\n\\n    // Particle previous = ssbo.particle[posGlobal.x];\\n    // Particle previous = Particle(ssbo.position[posGlobal.x], ssbo.velocity[posGlobal.x]);\\n    Particle previous = Particle(vec3(1), vec3(1));\\n    Particle next = previous;\\n\\n    vec2 positionMouse = u_positionMouse ;\\n    vec2 directionMouse = normalize(positionMouse - previous.position.xy );\\n\\n\\n    if (u_timeElapsed <=  0.) {\\n      ssbo.position[posGlobal.x] = vec3(0.5,0.5,1);\\n      ssbo.velocity[posGlobal.x] = vec3(0.5,0.5,1);\\n    } else {\\n      next.position.x = min(max(previous.position.x, 0.), 1.);\\n      next.position.y = min(max(previous.position.y, 0.), 1.);\\n\\n      next.position.xy += directionMouse*0.009;\\n\\n      ssbo.position[posGlobal.x] = next.position;\\n      ssbo.velocity[posGlobal.x] = next.velocity;\\n      // ssbo.data[posGlobal.x] = vec3(positionMouse, 0);\\n      // ssbo.data[posGlobal.x] = vec3(0.5,-0.5,1);\\n    }\\n\\n  }\\n\\n\\n\");\nexports.computeShaderSource = computeShaderSource;\nvar computeShaderSourceOld = \"#version 310 es\\n  layout (local_size_x = \".concat(1, \", local_size_y = 1, local_size_z = 1) in;\\n\\n  // layout (std140, binding = 0) buffer SSBOIn {\\n  //   Boids data[];\\n  //  } ssboIn;\\n\\n  struct Particle {\\n    vec3 position;\\n    vec3 velocity;\\n  }\\n  // shared Particle sharedData[\", 10, \"];\\n\\n  void main () {\\n    uint localThreadID = gl_LocallInvocationID.x;\\n    uint globalThreadID = gl_GlobalInvocationID.x;\\n    uint workGroupSize = gl_WorkGroupSize.x;\\n  }\\n\\n\\n\"); // export let fragmentShaderSource = `#version 310 es\n// precision mediump float;\n// // Passed in and varied from the vertex shader.\n// in vec3 v_normal;\n// uniform vec3 u_reverseLightDirection;\n// uniform vec4 u_color;\n// // we need to declare an output for the fragment shader\n// out vec4 outColor;\n// void main() {\n//   // because v_normal is a varying it's interpolated\n//   // so it will not be a uint vector. Normalizing it\n//   // will make it a unit vector again\n//   vec3 normal = normalize(v_normal);\n//   // compute the light by taking the dot product\n//   // of the normal to the light's reverse direction\n//   float light = dot(normal, u_reverseLightDirection);\n//   outColor = u_color;\n//   // Lets multiply just the color portion (not the alpha)\n//   // by the light\n//   outColor.rgb *= light;\n// }\n// `;\n\nexports.computeShaderSourceOld = computeShaderSourceOld;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":8,"column":0},"source":"src/shaders.js","original":{"line":1,"column":0}},{"generated":{"line":10,"column":0},"source":"src/shaders.js","original":{"line":2,"column":7}},{"name":"vertexShaderSource","generated":{"line":10,"column":4},"source":"src/shaders.js","original":{"line":2,"column":11}},{"generated":{"line":10,"column":22},"source":"src/shaders.js","original":{"line":2,"column":29}},{"generated":{"line":10,"column":1518},"source":"src/shaders.js","original":{"line":2,"column":7}},{"generated":{"line":12,"column":0},"source":"src/shaders.js","original":{"line":52,"column":7}},{"name":"fragmentShaderSource","generated":{"line":12,"column":4},"source":"src/shaders.js","original":{"line":52,"column":13}},{"generated":{"line":12,"column":24},"source":"src/shaders.js","original":{"line":52,"column":33}},{"generated":{"line":12,"column":194},"source":"src/shaders.js","original":{"line":52,"column":7}},{"generated":{"line":14,"column":0},"source":"src/shaders.js","original":{"line":66,"column":7}},{"name":"computeShaderSource","generated":{"line":14,"column":4},"source":"src/shaders.js","original":{"line":66,"column":13}},{"generated":{"line":14,"column":23},"source":"src/shaders.js","original":{"line":66,"column":32}},{"generated":{"line":14,"column":257},"source":"src/shaders.js","original":{"line":75,"column":20}},{"generated":{"line":14,"column":261},"source":"src/shaders.js","original":{"line":66,"column":32}},{"generated":{"line":14,"column":318},"source":"src/shaders.js","original":{"line":76,"column":20}},{"generated":{"line":14,"column":322},"source":"src/shaders.js","original":{"line":66,"column":32}},{"generated":{"line":14,"column":1473},"source":"src/shaders.js","original":{"line":66,"column":7}},{"generated":{"line":16,"column":0},"source":"src/shaders.js","original":{"line":114,"column":7}},{"name":"computeShaderSourceOld","generated":{"line":16,"column":4},"source":"src/shaders.js","original":{"line":114,"column":13}},{"generated":{"line":16,"column":26},"source":"src/shaders.js","original":{"line":114,"column":35}},{"generated":{"line":16,"column":81},"source":"src/shaders.js","original":{"line":115,"column":27}},{"generated":{"line":16,"column":82},"source":"src/shaders.js","original":{"line":114,"column":35}},{"generated":{"line":16,"column":323},"source":"src/shaders.js","original":{"line":125,"column":34}},{"generated":{"line":16,"column":325},"source":"src/shaders.js","original":{"line":114,"column":35}},{"generated":{"line":16,"column":512},"source":"src/shaders.js","original":{"line":114,"column":7}},{"generated":{"line":16,"column":514},"source":"src/shaders.js","original":{"line":136,"column":0}},{"generated":{"line":17,"column":0},"source":"src/shaders.js","original":{"line":138,"column":0}},{"generated":{"line":18,"column":0},"source":"src/shaders.js","original":{"line":140,"column":0}},{"generated":{"line":19,"column":0},"source":"src/shaders.js","original":{"line":141,"column":0}},{"generated":{"line":20,"column":0},"source":"src/shaders.js","original":{"line":143,"column":0}},{"generated":{"line":21,"column":0},"source":"src/shaders.js","original":{"line":144,"column":0}},{"generated":{"line":22,"column":0},"source":"src/shaders.js","original":{"line":146,"column":0}},{"generated":{"line":23,"column":0},"source":"src/shaders.js","original":{"line":147,"column":0}},{"generated":{"line":24,"column":0},"source":"src/shaders.js","original":{"line":149,"column":0}},{"generated":{"line":25,"column":0},"source":"src/shaders.js","original":{"line":150,"column":0}},{"generated":{"line":26,"column":0},"source":"src/shaders.js","original":{"line":151,"column":0}},{"generated":{"line":27,"column":0},"source":"src/shaders.js","original":{"line":152,"column":0}},{"generated":{"line":28,"column":0},"source":"src/shaders.js","original":{"line":153,"column":0}},{"generated":{"line":29,"column":0},"source":"src/shaders.js","original":{"line":155,"column":0}},{"generated":{"line":30,"column":0},"source":"src/shaders.js","original":{"line":156,"column":0}},{"generated":{"line":31,"column":0},"source":"src/shaders.js","original":{"line":157,"column":0}},{"generated":{"line":32,"column":0},"source":"src/shaders.js","original":{"line":159,"column":0}},{"generated":{"line":33,"column":0},"source":"src/shaders.js","original":{"line":161,"column":0}},{"generated":{"line":34,"column":0},"source":"src/shaders.js","original":{"line":162,"column":0}},{"generated":{"line":35,"column":0},"source":"src/shaders.js","original":{"line":163,"column":0}},{"generated":{"line":36,"column":0},"source":"src/shaders.js","original":{"line":164,"column":0}},{"generated":{"line":37,"column":0},"source":"src/shaders.js","original":{"line":165,"column":0}}],"sources":{"src/shaders.js":"import {NUM_PARTICLES} from './index'\r\nexport let vertexShaderSource = `#version 310 es\r\n\r\n\r\nin vec4 a_position;\r\n// in vec4 a_color;\r\n\r\n// layout (rgba8, binding = 0) uniform readonly highp image2D u_distTex;\r\n\r\nuniform mat4 u_matrix;\r\nuniform float u_fudgeFactor;\r\n// uniform sampler2D u_distTex;\r\nuniform int u_particleId;\r\nuniform int u_particleCount;\r\nuniform vec2 u_resolution;\r\nuniform vec2 u_positionMouse;\r\n\r\n// layout (std430, binding = 0) buffer SSBO {\r\n//   vec3 data[];\r\n// } ssbo;\r\nstruct Particle {\r\n  vec3 position;\r\n  vec3 velocity;\r\n};\r\nlayout (location = 0) in vec3 particle;\r\nlayout (location = 1) in vec3 particleVelocity;\r\n\r\nout vec4 v_color;\r\n\r\nvoid main() {\r\n  //vec4 position = u_matrix * a_position;\r\n\r\n  // float id = float(u_particleId);\r\n  float particleCount = float(u_particleCount);\r\n  // float fracId = id/particleCount;\r\n\r\n  Particle t = Particle(particle,particleVelocity);\r\n  // t *= 0.1;\r\n  // float t =   imageLoad(u_distTex,ivec2(u_particleId,0)).x;\r\n  // vec4 position = u_matrix * vec4(0. + sin(t.x)*1000. + fracId*u_resolution.x + u_positionMouse.x*u_resolution.y,0. + fracId*u_resolution.y ,1.,1.);\r\n  // vec4 position = u_matrix * vec4(0. + 1.*t.x*u_resolution.y + u_positionMouse.x*u_resolution.y,0. + t.y*u_resolution.y ,1.,1.);\r\n  vec4 position = u_matrix * vec4(0. + t.position.x*u_resolution.x,u_resolution.y-t.position.y*u_resolution.y,0.,1.);\r\n  \r\n  float zToDivideBy = 1.;\r\n  gl_PointSize = 10.0;\r\n  // v_color = a_color;\r\n  v_color = vec4(1);\r\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\r\n}\r\n`;\r\n\r\nexport const fragmentShaderSource = `#version 310 es\r\n\r\nprecision mediump float;\r\n\r\nin vec4 v_color;\r\n\r\nout vec4 outColor;\r\n\r\n\r\nvoid main() {\r\n  // outColor = v_color;\r\n  outColor = vec4(0,0,1,1.);\r\n}\r\n`;\r\nexport const computeShaderSource = `#version 310 es\r\n  layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\r\n\r\n  struct Particle {\r\n    vec3 position;\r\n    vec3 velocity;\r\n  };\r\n\r\n  layout (std430, binding = 0) buffer SSBO {\r\n    vec3 position[${1000}]; // TODO: make this an import\r\n    vec3 velocity[${1000}];\r\n  } ssbo;\r\n\r\n  uniform vec2 u_resolution;\r\n  uniform vec2 u_positionMouse;\r\n  uniform int u_particleCount;\r\n  uniform float u_timeElapsed;\r\n  void main() {\r\n    ivec2 posGlobal = ivec2(gl_GlobalInvocationID.xy);\r\n\r\n    // Particle previous = ssbo.particle[posGlobal.x];\r\n    // Particle previous = Particle(ssbo.position[posGlobal.x], ssbo.velocity[posGlobal.x]);\r\n    Particle previous = Particle(vec3(1), vec3(1));\r\n    Particle next = previous;\r\n\r\n    vec2 positionMouse = u_positionMouse ;\r\n    vec2 directionMouse = normalize(positionMouse - previous.position.xy );\r\n\r\n\r\n    if (u_timeElapsed <=  0.) {\r\n      ssbo.position[posGlobal.x] = vec3(0.5,0.5,1);\r\n      ssbo.velocity[posGlobal.x] = vec3(0.5,0.5,1);\r\n    } else {\r\n      next.position.x = min(max(previous.position.x, 0.), 1.);\r\n      next.position.y = min(max(previous.position.y, 0.), 1.);\r\n\r\n      next.position.xy += directionMouse*0.009;\r\n\r\n      ssbo.position[posGlobal.x] = next.position;\r\n      ssbo.velocity[posGlobal.x] = next.velocity;\r\n      // ssbo.data[posGlobal.x] = vec3(positionMouse, 0);\r\n      // ssbo.data[posGlobal.x] = vec3(0.5,-0.5,1);\r\n    }\r\n\r\n  }\r\n\r\n\r\n`;\r\nexport const computeShaderSourceOld = `#version 310 es\r\n  layout (local_size_x = ${1}, local_size_y = 1, local_size_z = 1) in;\r\n\r\n  // layout (std140, binding = 0) buffer SSBOIn {\r\n  //   Boids data[];\r\n  //  } ssboIn;\r\n\r\n  struct Particle {\r\n    vec3 position;\r\n    vec3 velocity;\r\n  }\r\n  // shared Particle sharedData[${10}];\r\n\r\n  void main () {\r\n    uint localThreadID = gl_LocallInvocationID.x;\r\n    uint globalThreadID = gl_GlobalInvocationID.x;\r\n    uint workGroupSize = gl_WorkGroupSize.x;\r\n  }\r\n\r\n\r\n`;\r\n\r\n// export let fragmentShaderSource = `#version 310 es\r\n\r\n// precision mediump float;\r\n\r\n// // Passed in and varied from the vertex shader.\r\n// in vec3 v_normal;\r\n\r\n// uniform vec3 u_reverseLightDirection;\r\n// uniform vec4 u_color;\r\n\r\n// // we need to declare an output for the fragment shader\r\n// out vec4 outColor;\r\n\r\n// void main() {\r\n//   // because v_normal is a varying it's interpolated\r\n//   // so it will not be a uint vector. Normalizing it\r\n//   // will make it a unit vector again\r\n//   vec3 normal = normalize(v_normal);\r\n\r\n//   // compute the light by taking the dot product\r\n//   // of the normal to the light's reverse direction\r\n//   float light = dot(normal, u_reverseLightDirection);\r\n\r\n//   outColor = u_color;\r\n\r\n//   // Lets multiply just the color portion (not the alpha)\r\n//   // by the light\r\n//   outColor.rgb *= light;\r\n// }\r\n// `;\r\n"},"lineCount":null}},"error":null,"hash":"39968bf0dba48178e362eee84289a9ce","cacheData":{"env":{}}}