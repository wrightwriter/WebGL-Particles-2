{"id":"src/shaders.js","dependencies":[{"name":"Z:\\ProgrammingProjects\\VisualAudio\\particle-system-webgl\\WebGL-Particle-nator\\package.json","includedInParent":true,"mtime":1578144868423}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeShaderSourceOld = exports.computeShaderSource = exports.fragmentShaderSource = exports.vertexShaderSource = void 0;\nvar vertexShaderSource = \"#version 300 es\\n\\nin vec4 a_position;\\n// in vec4 a_color;\\n\\nuniform mat4 u_matrix;\\nuniform float u_fudgeFactor;\\nuniform sampler2D u_distTex;\\nuniform int u_particleId;\\nuniform int u_particleCount;\\n\\nout vec4 v_color;\\n\\nvoid main() {\\n  //vec4 position = u_matrix * a_position;\\n\\n  float id = float(u_particleId);\\n  float count = float(u_particleCount);\\n  float t =   texture(u_distTex,vec2(id/count,1)).x;\\n  vec4 position = u_matrix * vec4(45.  + t*100.,150,0.6,1);\\n  \\n  //position.x *= 0.5;\\n  // float zToDivideBy = 1.0 + position.z * u_fudgeFactor;\\n  float zToDivideBy = 1.;\\n  gl_PointSize = 3.0;\\n  // v_color = a_color;\\n  v_color = vec4(1);\\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\\n}\\n\";\nexports.vertexShaderSource = vertexShaderSource;\nvar fragmentShaderSource = \"#version 300 es\\n\\nprecision mediump float;\\n\\nin vec4 v_color;\\n\\nout vec4 outColor;\\n\\nvoid main() {\\n  // outColor = v_color;\\n  outColor = vec4(0,0,1,1.);\\n}\\n\";\nexports.fragmentShaderSource = fragmentShaderSource;\nvar computeShaderSource = \"#version 310 es\\n  layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\\n  layout (rgba8, binding = 0) writeonly uniform highp image2D destTex;\\n\\n  void main() {\\n    ivec2 posGlobal = ivec2(gl_GlobalInvocationID.xy);\\n    //imageStore(destTex, storePos, vec4(vec2(gl_WorkGroupID.xy) / vec2(gl_NumWorkGroups.xy), 0.0, 1.0));\\n  }\\n\\n\";\nexports.computeShaderSource = computeShaderSource;\nvar computeShaderSourceOld = \"#version 310 es\\n  layout (local_size_x = \".concat(10, \", local_size_y = 1, local_size_z = 1) in;\\n\\n  // layout (std140, binding = 0) buffer SSBOIn {\\n  //   Boids data[];\\n  //  } ssboIn;\\n\\n  struct Particle {\\n    vec3 position;\\n    vec3 velocity;\\n  }\\n  // shared Particle sharedData[\", 10, \"];\\n\\n  void main () {\\n    uint localThreadID = gl_LocallInvocationID.x;\\n    uint globalThreadID = gl_GlobalInvocationID.x;\\n    uint workGroupSize = gl_WorkGroupSize.x;\\n  }\\n\\n\\n\"); // export let fragmentShaderSource = `#version 310 es\n// precision mediump float;\n// // Passed in and varied from the vertex shader.\n// in vec3 v_normal;\n// uniform vec3 u_reverseLightDirection;\n// uniform vec4 u_color;\n// // we need to declare an output for the fragment shader\n// out vec4 outColor;\n// void main() {\n//   // because v_normal is a varying it's interpolated\n//   // so it will not be a uint vector. Normalizing it\n//   // will make it a unit vector again\n//   vec3 normal = normalize(v_normal);\n//   // compute the light by taking the dot product\n//   // of the normal to the light's reverse direction\n//   float light = dot(normal, u_reverseLightDirection);\n//   outColor = u_color;\n//   // Lets multiply just the color portion (not the alpha)\n//   // by the light\n//   outColor.rgb *= light;\n// }\n// `;\n\nexports.computeShaderSourceOld = computeShaderSourceOld;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":7,"column":0},"source":"src/shaders.js","original":{"line":1,"column":7}},{"name":"vertexShaderSource","generated":{"line":7,"column":4},"source":"src/shaders.js","original":{"line":1,"column":11}},{"generated":{"line":7,"column":22},"source":"src/shaders.js","original":{"line":1,"column":29}},{"generated":{"line":7,"column":757},"source":"src/shaders.js","original":{"line":1,"column":7}},{"generated":{"line":9,"column":0},"source":"src/shaders.js","original":{"line":32,"column":7}},{"name":"fragmentShaderSource","generated":{"line":9,"column":4},"source":"src/shaders.js","original":{"line":32,"column":13}},{"generated":{"line":9,"column":24},"source":"src/shaders.js","original":{"line":32,"column":33}},{"generated":{"line":9,"column":192},"source":"src/shaders.js","original":{"line":32,"column":7}},{"generated":{"line":11,"column":0},"source":"src/shaders.js","original":{"line":45,"column":7}},{"name":"computeShaderSource","generated":{"line":11,"column":4},"source":"src/shaders.js","original":{"line":45,"column":13}},{"generated":{"line":11,"column":23},"source":"src/shaders.js","original":{"line":45,"column":32}},{"generated":{"line":11,"column":375},"source":"src/shaders.js","original":{"line":45,"column":7}},{"generated":{"line":13,"column":0},"source":"src/shaders.js","original":{"line":55,"column":7}},{"name":"computeShaderSourceOld","generated":{"line":13,"column":4},"source":"src/shaders.js","original":{"line":55,"column":13}},{"generated":{"line":13,"column":26},"source":"src/shaders.js","original":{"line":55,"column":35}},{"generated":{"line":13,"column":81},"source":"src/shaders.js","original":{"line":56,"column":27}},{"generated":{"line":13,"column":83},"source":"src/shaders.js","original":{"line":55,"column":35}},{"generated":{"line":13,"column":324},"source":"src/shaders.js","original":{"line":66,"column":34}},{"generated":{"line":13,"column":326},"source":"src/shaders.js","original":{"line":55,"column":35}},{"generated":{"line":13,"column":513},"source":"src/shaders.js","original":{"line":55,"column":7}},{"generated":{"line":13,"column":515},"source":"src/shaders.js","original":{"line":77,"column":0}},{"generated":{"line":14,"column":0},"source":"src/shaders.js","original":{"line":79,"column":0}},{"generated":{"line":15,"column":0},"source":"src/shaders.js","original":{"line":81,"column":0}},{"generated":{"line":16,"column":0},"source":"src/shaders.js","original":{"line":82,"column":0}},{"generated":{"line":17,"column":0},"source":"src/shaders.js","original":{"line":84,"column":0}},{"generated":{"line":18,"column":0},"source":"src/shaders.js","original":{"line":85,"column":0}},{"generated":{"line":19,"column":0},"source":"src/shaders.js","original":{"line":87,"column":0}},{"generated":{"line":20,"column":0},"source":"src/shaders.js","original":{"line":88,"column":0}},{"generated":{"line":21,"column":0},"source":"src/shaders.js","original":{"line":90,"column":0}},{"generated":{"line":22,"column":0},"source":"src/shaders.js","original":{"line":91,"column":0}},{"generated":{"line":23,"column":0},"source":"src/shaders.js","original":{"line":92,"column":0}},{"generated":{"line":24,"column":0},"source":"src/shaders.js","original":{"line":93,"column":0}},{"generated":{"line":25,"column":0},"source":"src/shaders.js","original":{"line":94,"column":0}},{"generated":{"line":26,"column":0},"source":"src/shaders.js","original":{"line":96,"column":0}},{"generated":{"line":27,"column":0},"source":"src/shaders.js","original":{"line":97,"column":0}},{"generated":{"line":28,"column":0},"source":"src/shaders.js","original":{"line":98,"column":0}},{"generated":{"line":29,"column":0},"source":"src/shaders.js","original":{"line":100,"column":0}},{"generated":{"line":30,"column":0},"source":"src/shaders.js","original":{"line":102,"column":0}},{"generated":{"line":31,"column":0},"source":"src/shaders.js","original":{"line":103,"column":0}},{"generated":{"line":32,"column":0},"source":"src/shaders.js","original":{"line":104,"column":0}},{"generated":{"line":33,"column":0},"source":"src/shaders.js","original":{"line":105,"column":0}},{"generated":{"line":34,"column":0},"source":"src/shaders.js","original":{"line":106,"column":0}}],"sources":{"src/shaders.js":"export let vertexShaderSource = `#version 300 es\r\n\r\nin vec4 a_position;\r\n// in vec4 a_color;\r\n\r\nuniform mat4 u_matrix;\r\nuniform float u_fudgeFactor;\r\nuniform sampler2D u_distTex;\r\nuniform int u_particleId;\r\nuniform int u_particleCount;\r\n\r\nout vec4 v_color;\r\n\r\nvoid main() {\r\n  //vec4 position = u_matrix * a_position;\r\n\r\n  float id = float(u_particleId);\r\n  float count = float(u_particleCount);\r\n  float t =   texture(u_distTex,vec2(id/count,1)).x;\r\n  vec4 position = u_matrix * vec4(45.  + t*100.,150,0.6,1);\r\n  \r\n  //position.x *= 0.5;\r\n  // float zToDivideBy = 1.0 + position.z * u_fudgeFactor;\r\n  float zToDivideBy = 1.;\r\n  gl_PointSize = 3.0;\r\n  // v_color = a_color;\r\n  v_color = vec4(1);\r\n  gl_Position = vec4(position.xy / zToDivideBy, position.zw);\r\n}\r\n`;\r\n\r\nexport const fragmentShaderSource = `#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nin vec4 v_color;\r\n\r\nout vec4 outColor;\r\n\r\nvoid main() {\r\n  // outColor = v_color;\r\n  outColor = vec4(0,0,1,1.);\r\n}\r\n`;\r\nexport const computeShaderSource = `#version 310 es\r\n  layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;\r\n  layout (rgba8, binding = 0) writeonly uniform highp image2D destTex;\r\n\r\n  void main() {\r\n    ivec2 posGlobal = ivec2(gl_GlobalInvocationID.xy);\r\n    //imageStore(destTex, storePos, vec4(vec2(gl_WorkGroupID.xy) / vec2(gl_NumWorkGroups.xy), 0.0, 1.0));\r\n  }\r\n\r\n`;\r\nexport const computeShaderSourceOld = `#version 310 es\r\n  layout (local_size_x = ${10}, local_size_y = 1, local_size_z = 1) in;\r\n\r\n  // layout (std140, binding = 0) buffer SSBOIn {\r\n  //   Boids data[];\r\n  //  } ssboIn;\r\n\r\n  struct Particle {\r\n    vec3 position;\r\n    vec3 velocity;\r\n  }\r\n  // shared Particle sharedData[${10}];\r\n\r\n  void main () {\r\n    uint localThreadID = gl_LocallInvocationID.x;\r\n    uint globalThreadID = gl_GlobalInvocationID.x;\r\n    uint workGroupSize = gl_WorkGroupSize.x;\r\n  }\r\n\r\n\r\n`;\r\n\r\n// export let fragmentShaderSource = `#version 310 es\r\n\r\n// precision mediump float;\r\n\r\n// // Passed in and varied from the vertex shader.\r\n// in vec3 v_normal;\r\n\r\n// uniform vec3 u_reverseLightDirection;\r\n// uniform vec4 u_color;\r\n\r\n// // we need to declare an output for the fragment shader\r\n// out vec4 outColor;\r\n\r\n// void main() {\r\n//   // because v_normal is a varying it's interpolated\r\n//   // so it will not be a uint vector. Normalizing it\r\n//   // will make it a unit vector again\r\n//   vec3 normal = normalize(v_normal);\r\n\r\n//   // compute the light by taking the dot product\r\n//   // of the normal to the light's reverse direction\r\n//   float light = dot(normal, u_reverseLightDirection);\r\n\r\n//   outColor = u_color;\r\n\r\n//   // Lets multiply just the color portion (not the alpha)\r\n//   // by the light\r\n//   outColor.rgb *= light;\r\n// }\r\n// `;\r\n"},"lineCount":null}},"error":null,"hash":"09a82599f88d382067065e455aab5313","cacheData":{"env":{}}}